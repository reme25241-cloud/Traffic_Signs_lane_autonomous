{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Three.js Neighborhood â€” AI Car with Smooth Parking + Lane Detection</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }

    #hud {
      position: fixed;
      left: 20px;
      top: 20px;
      color: #ffffff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: rgba(0, 0, 0, 0.55);
      padding: 8px 14px;
      border-radius: 6px;
      min-width: 220px;
      font-size: 14px;
      pointer-events: none;
      white-space: pre-line;
      line-height: 1.35;
    }
  </style>
</head>
<body>

<div id="hud"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
/* ======================================================
   BASIC SCENE SETUP
====================================================== */
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  70,
  window.innerWidth / window.innerHeight,
  0.1,
  2000
);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const hudEl = document.getElementById("hud");
let lastHUDMsg = "";
function updateHUD(msg) {
  if (!hudEl) return;
  if (msg === lastHUDMsg) return;
  lastHUDMsg = msg;
  hudEl.textContent = msg || "";
}

/* ======================================================
   BACKGROUND SKY
====================================================== */
const loader = new THREE.TextureLoader();
loader.load("{% static 'img/sky.png' %}", (texture) => {
  scene.background = texture;
});

/* ======================================================
   ROAD / LANE CONSTANTS
====================================================== */
const roadWidth  = 10;
const laneWidth  = 3.2;
const roadLength = 2000;
const lanePositions = [-laneWidth, 0, laneWidth]; // 3 lanes

/* Parking zone definition */
const parkingZoneZMin = -800;
const parkingZoneZMax = -700;
const parkingLaneIndex = 0;           // left lane for approach
const parkingSlotsCount = 6;
const parkingSlots = [];
const parkingAreaX = -(roadWidth / 2 + 4); // left side of road
const parkingZoneTriggerZ = -650;     // when AI starts planning to park

/* ======================================================
   GROUND
====================================================== */
loader.load("{% static 'img/ground.png' %}", (texture) => {
  texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(40, 40);

  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(2000, 2000),
    new THREE.MeshLambertMaterial({ map: texture })
  );
  ground.rotation.x = -Math.PI / 2;
  ground.position.y = 0;
  scene.add(ground);
});

/* ======================================================
   MAIN ROAD (3 LANES)
====================================================== */
const road = new THREE.Mesh(
  new THREE.PlaneGeometry(roadWidth, roadLength),
  new THREE.MeshPhongMaterial({ color: 0x444444 })
);
road.rotation.x = -Math.PI / 2;
road.position.y = 0.04;
scene.add(road);

// Lane divider lines
for (let z = -1000; z < 1000; z += 8) {
  const stripeGeo = new THREE.PlaneGeometry(0.15, 2);
  const stripeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
  const stripe1   = new THREE.Mesh(stripeGeo, stripeMat);
  stripe1.rotation.x = -Math.PI / 2;
  stripe1.position.set(-laneWidth / 2, 0.05, z);
  scene.add(stripe1);

  const stripe2 = stripe1.clone();
  stripe2.position.x = laneWidth / 2;
  scene.add(stripe2);
}

/* ======================================================
   LANE DETECTION VISUAL (HIGHLIGHT CURRENT DETECTED LANE)
====================================================== */
const laneHighlight = new THREE.Mesh(
  new THREE.PlaneGeometry(laneWidth * 0.92, 10),
  new THREE.MeshBasicMaterial({
    color: 0x00ffff,
    transparent: true,
    opacity: 0.14
  })
);
laneHighlight.rotation.x = -Math.PI / 2;
laneHighlight.position.y = 0.055;
laneHighlight.visible = true;
scene.add(laneHighlight);

/* ======================================================
   FOOTPATHS
====================================================== */
const footpathWidth = 2;
const fpGeo = new THREE.BoxGeometry(footpathWidth, 0.1, roadLength);
const fpMat = new THREE.MeshPhongMaterial({ color: 0xcfcfcf });

const leftFP = new THREE.Mesh(fpGeo, fpMat);
leftFP.position.set(-(roadWidth / 2 + footpathWidth / 2), 0.1, 0);

const rightFP = new THREE.Mesh(fpGeo, fpMat);
rightFP.position.set(roadWidth / 2 + footpathWidth / 2, 0.1, 0);

scene.add(leftFP, rightFP);

/* ======================================================
   INTERSECTIONS
====================================================== */
function createIntersection(z) {
  const interLength = 40;
  const interWidth  = roadWidth;

  const horizRoad = new THREE.Mesh(
    new THREE.PlaneGeometry(interLength, interWidth),
    new THREE.MeshPhongMaterial({ color: 0x303030 })
  );
  horizRoad.rotation.x = -Math.PI / 2;
  horizRoad.position.set(0, 0.041, z);
  scene.add(horizRoad);
}

for (let z = -900; z < 900; z += 300) {
  createIntersection(z);
}

/* ======================================================
   POTHOLES  (lane-aware)
====================================================== */
const potholes = [];

function createPothole(laneIndex, z, size = 1.2 + Math.random() * 1.2) {
  const x = lanePositions[laneIndex];

  const innerGeo = new THREE.CircleGeometry(size, 24);
  const innerMat = new THREE.MeshPhongMaterial({
    color: 0x0a0a0a,
    side: THREE.DoubleSide
  });
  const inner = new THREE.Mesh(innerGeo, innerMat);
  inner.rotation.x = -Math.PI / 2;
  inner.position.set(x, 0.037, z);
  scene.add(inner);

  const rimGeo = new THREE.RingGeometry(size * 0.9, size * 1.3, 24);
  const rimMat = new THREE.MeshPhongMaterial({
    color: 0x222222,
    side: THREE.DoubleSide
  });
  const rim = new THREE.Mesh(rimGeo, rimMat);
  rim.rotation.x = -Math.PI / 2;
  rim.position.set(x, 0.038, z);
  scene.add(rim);

  potholes.push({ x, z, r: size, laneIndex });
}

// Random potholes
for (let z = -900; z < 900; z += 40) {
  if (Math.random() < 0.5) {
    const laneIndex = Math.floor(Math.random() * 3);
    createPothole(laneIndex, z);
  }
}

/* ======================================================
   TREES + BUNGALOWS
====================================================== */
function createTree(x, z) {
  const trunk = new THREE.Mesh(
    new THREE.CylinderGeometry(0.2, 0.2, 2),
    new THREE.MeshLambertMaterial({ color: 0x8b4513 })
  );
  const leaves = new THREE.Mesh(
    new THREE.SphereGeometry(1.3),
    new THREE.MeshLambertMaterial({ color: 0x006400 })
  );
  trunk.position.set(x, 1, z);
  leaves.position.set(x, 2.4, z);
  scene.add(trunk, leaves);
}

for (let z = -1000; z < 1000; z += 20) {
  createTree(-roadWidth / 2 - 3, z + Math.random() * 5);
  createTree( roadWidth / 2 + 3, z + Math.random() * 5);
}

function createBungalow(x, z) {
  const w = 6, d = 5, h = 3;

  const house = new THREE.Mesh(
    new THREE.BoxGeometry(w, h, d),
    new THREE.MeshLambertMaterial({ color: 0xfff2e6 })
  );
  house.position.set(x, h / 2, z);

  const roof = new THREE.Mesh(
    new THREE.CylinderGeometry(w * 0.9, w * 0.9, 1.5, 4),
    new THREE.MeshLambertMaterial({ color: 0x8b0000 })
  );
  roof.position.set(x, h + 0.75, z);
  roof.rotation.y = Math.PI / 4;

  scene.add(house, roof);
}

// Leave clear space for parking zone
for (let z = -1000; z < 1000; z += 30) {
  if (z > parkingZoneZMin - 10 && z < parkingZoneZMax + 10) continue;
  createBungalow(-(roadWidth / 2 + footpathWidth + 6), z);
  createBungalow( roadWidth / 2 + footpathWidth + 6, z);
}

/* ======================================================
   CLOUDS + BIRDS
====================================================== */
const clouds = [];
const birds  = [];

function createCloud(x, y, z) {
  const cloud = new THREE.Group();
  const puffGeo = new THREE.SphereGeometry(2, 16, 16);
  const puffMat = new THREE.MeshLambertMaterial({ color: 0xffffff });

  for (let i = 0; i < 3; i++) {
    const puff = new THREE.Mesh(puffGeo, puffMat);
    puff.position.set(i * 2 - 2, Math.random() * 1, 0);
    cloud.add(puff);
  }

  cloud.position.set(x, y, z);
  scene.add(cloud);
  return cloud;
}

for (let i = 0; i < 7; i++) {
  clouds.push(
    createCloud(
      -200 + Math.random() * 400,
      30 + Math.random() * 10,
      -200 + Math.random() * 400
    )
  );
}

function createBird(x, y, z) {
  const bird = new THREE.Group();
  const wingGeo = new THREE.BoxGeometry(1.5, 0.1, 0.3);
  const wingMat = new THREE.MeshLambertMaterial({ color: 0x000000 });

  const lw = new THREE.Mesh(wingGeo, wingMat);
  lw.rotation.z = 0.6;
  lw.position.x = -0.5;

  const rw = new THREE.Mesh(wingGeo, wingMat);
  rw.rotation.z = -0.6;
  rw.position.x = 0.5;

  bird.add(lw, rw);
  bird.position.set(x, y, z);
  scene.add(bird);
  return bird;
}

for (let i = 0; i < 10; i++) {
  birds.push(
    createBird(
      -200 + Math.random() * 400,
      25 + Math.random() * 8,
      -200 + Math.random() * 400
    )
  );
}

/* ======================================================
   PARKING AREA + SLOTS
====================================================== */
function createParkingArea() {
  const length = parkingSlotsCount * 7;
  const width  = 4;

  const area = new THREE.Mesh(
    new THREE.PlaneGeometry(width, length),
    new THREE.MeshPhongMaterial({ color: 0x555555 })
  );
  area.rotation.x = -Math.PI / 2;
  const centerZ = (parkingZoneZMin + parkingZoneZMax) / 2;
  area.position.set(parkingAreaX, 0.041, centerZ);
  scene.add(area);

  const slotSpacing = 7;
  const firstZ = centerZ - (slotSpacing * (parkingSlotsCount - 1)) / 2;
  for (let i = 0; i < parkingSlotsCount; i++) {
    const slotZ = firstZ + i * slotSpacing;
    const slotX = parkingAreaX;

    const lineGeo = new THREE.PlaneGeometry(width - 0.5, 0.12);
    const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const line = new THREE.Mesh(lineGeo, lineMat);
    line.rotation.x = -Math.PI / 2;
    line.position.set(slotX, 0.042, slotZ - 3);
    scene.add(line);

    parkingSlots.push({
      x: slotX,
      z: slotZ,
      occupiedStatic: false,
      carMesh: null
    });
  }
}

function createCarMesh(color = 0xffffff) {
  const car = new THREE.Group();

  const body = new THREE.Mesh(
    new THREE.BoxGeometry(1.4, 0.6, 3),
    new THREE.MeshPhongMaterial({ color })
  );
  body.position.y = 0.5;
  car.add(body);

  const wheelGeo = new THREE.CylinderGeometry(0.25, 0.25, 1, 16);
  const wheelMat = new THREE.MeshPhongMaterial({ color: 0x111111 });

  function addWheel(px, pz) {
    const w = new THREE.Mesh(wheelGeo, wheelMat);
    w.rotation.z = Math.PI / 2;
    w.position.set(px, 0.25, pz);
    car.add(w);
  }

  addWheel(-0.6, -1);
  addWheel( 0.6, -1);
  addWheel(-0.6,  1);
  addWheel( 0.6,  1);

  return car;
}

function populateParkingWithCars() {
  parkingSlots.forEach((slot) => {
    if (Math.random() < 0.55) {
      const parked = createCarMesh(0x999999);
      parked.position.set(slot.x, 0.05, slot.z);
      scene.add(parked);
      slot.occupiedStatic = true;
      slot.carMesh = parked;
    }
  });
}

createParkingArea();
populateParkingWithCars();

/* ======================================================
   TRAFFIC LIGHTS
====================================================== */
const trafficLights = [];

function createTrafficLight(x, z) {
  const group = new THREE.Group();

  const pole = new THREE.Mesh(
    new THREE.CylinderGeometry(0.12, 0.12, 5),
    new THREE.MeshPhongMaterial({ color: 0x222222 })
  );
  pole.position.set(0, 2.5, 0);
  group.add(pole);

  const box = new THREE.Mesh(
    new THREE.BoxGeometry(1, 2, 0.6),
    new THREE.MeshPhongMaterial({ color: 0x000000 })
  );
  box.position.set(0, 4, 0);
  group.add(box);

  const lightGeo = new THREE.CircleGeometry(0.35, 24);
  const red    = new THREE.Mesh(lightGeo, new THREE.MeshBasicMaterial({ color: 0x440000 }));
  const yellow = new THREE.Mesh(lightGeo, new THREE.MeshBasicMaterial({ color: 0x443300 }));
  const green  = new THREE.Mesh(lightGeo, new THREE.MeshBasicMaterial({ color: 0x003300 }));

  red.position.set(0, 4.55, 0.31);
  yellow.position.set(0, 4.0,  0.31);
  green.position.set(0, 3.45, 0.31);

  group.add(red, yellow, green);

  group.position.set(x, 0, z);
  if (x < 0) group.rotation.y = Math.PI;
  scene.add(group);

  trafficLights.push({
    red,
    yellow,
    green,
    x,
    z,
    state: "green",
    timer: Math.random() * 3
  });
}

for (let z = -900; z < 900; z += 300) {
  createTrafficLight(-roadWidth / 2 + 0.5, z);
  createTrafficLight( roadWidth / 2 - 0.5, z);
}

function updateTrafficLights(delta) {
  trafficLights.forEach((tl) => {
    tl.timer += delta;
    switch (tl.state) {
      case "green":
        if (tl.timer > 5) { tl.state = "yellow"; tl.timer = 0; }
        break;
      case "yellow":
        if (tl.timer > 2) { tl.state = "red";    tl.timer = 0; }
        break;
      case "red":
        if (tl.timer > 5) { tl.state = "green";  tl.timer = 0; }
        break;
    }

    tl.red.material.color.set(tl.state === "red"    ? 0xff0000 : 0x440000);
    tl.yellow.material.color.set(tl.state === "yellow" ? 0xffff00 : 0x443300);
    tl.green.material.color.set(tl.state === "green"  ? 0x00ff00 : 0x003300);
  });
}

/* ======================================================
   CAR SYSTEM
====================================================== */
const obstacleCars = [];
let   aiCar         = null;

function createTrafficCar(z, laneIndex, speed) {
  const color = Math.random() * 0xffffff;
  const car   = createCarMesh(color);

  car.position.set(lanePositions[laneIndex], 0.05, z);
  car.userData = {
    laneIndex,
    speed,
  };

  scene.add(car);
  obstacleCars.push(car);
}

/* ---------- AI Car ---------- */
function createAICar(z, laneIndex) {
  const car = createCarMesh(0xffaa00);

  car.position.set(lanePositions[laneIndex], 0.05, z);

  car.userData = {
    laneIndex,
    targetLaneIndex: laneIndex,
    laneChangeFrom: laneIndex,
    isChangingLane: false,
    laneChangeT: 0,
    laneChangeDuration: 1.0,
    currentSpeed: 0,
    baseMaxSpeed: 14,
    accel: 10,
    decel: 18,
    lastLaneChangeTime: 0,
    laneChangeCooldown: 2,

    drivingState: "DRIVING", // DRIVING | GOING_TO_PARK | PARKING_STRAIGHT | PARKED
    parkingSlotIndex: null,
    parkingTimer: 0,

    // parking straight (two phases: along Z then along X)
    parkingPhase: 0,       // 0=none, 1=along Z, 2=along X
    parkingZStart: 0,
    parkingZEnd: 0,
    parkingXStart: 0,
    parkingXEnd: 0,
    parkingT: 0,
    parkingDurZ: 1.2,
    parkingDurX: 1.0
  };

  scene.add(car);
  return car;
}

/* ======================================================
   AI HELPERS
====================================================== */
function smoothStep(t) {
  return t * t * (3 - 2 * t);
}

/* ---------- LANE DETECTION + LANE KEEP ASSIST ---------- */
const laneDetect = {
  enabled: true,
  autoCenter: true,          // gentle lane keeping when cruising
  warnDist: laneWidth * 0.35,
  maxSnapDist: laneWidth * 0.9,
  steerStrength: 6.5         // higher = stronger recentre
};

function detectLaneAtX(x) {
  let bestLane = 0;
  let bestAbs  = Infinity;
  for (let i = 0; i < lanePositions.length; i++) {
    const d = x - lanePositions[i];
    const a = Math.abs(d);
    if (a < bestAbs) {
      bestAbs = a;
      bestLane = i;
    }
  }
  return {
    laneIndex: bestLane,
    offset: x - lanePositions[bestLane],
    absOffset: bestAbs
  };
}

function laneStatusText(laneInfo) {
  let status = "OK";
  if (laneInfo.absOffset > laneDetect.maxSnapDist) status = "OFF-LANE";
  else if (laneInfo.absOffset > laneDetect.warnDist) status = "DRIFT";
  return `Lane ${laneInfo.laneIndex + 1}/3 (${status}) | Drift: ${laneInfo.offset.toFixed(2)}`;
}

function findPotholeAhead(carZ, laneIndex, maxDist) {
  let best = null;
  for (const p of potholes) {
    if (p.laneIndex !== laneIndex) continue;
    if (carZ > p.z) {
      const dist = carZ - p.z;
      if (dist < maxDist) {
        if (!best || dist < best.dist) best = { ...p, dist };
      }
    }
  }
  return best;
}

function findCarAhead(carZ, laneIndex, maxDist) {
  let best = null;
  for (const c of obstacleCars) {
    if (c.userData.laneIndex !== laneIndex) continue;
    if (c.position.z < carZ) {
      const dist = carZ - c.position.z;
      if (dist < maxDist) {
        if (!best || dist < best.dist) best = { car: c, dist };
      }
    }
  }
  return best;
}

function findCarBehind(carZ, laneIndex, maxDist) {
  let best = null;
  for (const c of obstacleCars) {
    if (c.userData.laneIndex !== laneIndex) continue;
    if (c.position.z > carZ) {
      const dist = c.position.z - carZ; // behind -> larger z
      if (dist < maxDist) {
        if (!best || dist < best.dist) best = { car: c, dist };
      }
    }
  }
  return best;
}

function findRedOrYellowLightAhead(carZ) {
  let best = null;
  const BRAKING_RANGE = 60;

  for (const tl of trafficLights) {
    if (tl.state !== "red" && tl.state !== "yellow") continue;

    const stopZ = tl.z + 2;
    if (carZ > stopZ) {
      const dist = carZ - stopZ;
      if (dist < BRAKING_RANGE) {
        if (!best || dist < best.dist) best = { dist, stopZ, state: tl.state };
      }
    }
  }
  return best;
}

function canChangeToLane(carZ, newLaneIndex) {
  if (newLaneIndex < 0 || newLaneIndex > 2) return false;

  const safeGap = 10;

  for (const c of obstacleCars) {
    if (c.userData.laneIndex !== newLaneIndex) continue;
    const dz = Math.abs(c.position.z - carZ);
    if (dz < safeGap) return false;
  }

  for (const p of potholes) {
    if (p.laneIndex !== newLaneIndex) continue;
    if (carZ > p.z) {
      const dist = carZ - p.z;
      if (dist < 12) return false;
    }
  }

  return true;
}

/* ======================================================
   CREATE AI CAR + TRAFFIC CARS
====================================================== */
const aiStartLane = Math.floor(Math.random() * 3);
const aiStartZ    = 120;
aiCar = createAICar(aiStartZ, aiStartLane);

for (let lane = 0; lane < 3; lane++) {
  for (let z = -900; z < 900; z += 40) {
    if (lane === aiStartLane && Math.abs(z - aiStartZ) < 80) continue;
    const speed = 8 + Math.random() * 5;
    createTrafficCar(z, lane, speed);
  }
}

/* ======================================================
   UPDATE OBSTACLE CARS (FOLLOW SIGNALS + NO BUMPING)
====================================================== */
function updateObstacleCars(delta) {
  const BRAKING_RANGE = 40;
  const minGap = 5;

  obstacleCars.forEach((car) => {
    const baseSpeed = car.userData.speed;
    let   speed     = baseSpeed;
    const carZ      = car.position.z;

    const lightInfo = findRedOrYellowLightAhead(carZ);
    if (lightInfo) {
      const t = Math.max(0, Math.min(1, lightInfo.dist / BRAKING_RANGE));
      speed = baseSpeed * t;
      if (lightInfo.dist < 2) speed = 0;
    }

    car.position.z -= speed * delta;

    if (car.position.z < -950) {
      car.position.z = 850;
    }
  });

  for (let lane = 0; lane < 3; lane++) {
    const laneCars = obstacleCars.filter(c => c.userData.laneIndex === lane);

    if (
      aiCar &&
      aiCar.userData.drivingState !== "PARKED" &&
      Math.abs(aiCar.position.x - lanePositions[lane]) < laneWidth * 0.6
    ) {
      laneCars.push(aiCar);
    }

    laneCars.sort((a, b) => a.position.z - b.position.z);

    for (let i = 1; i < laneCars.length; i++) {
      const front = laneCars[i - 1];
      const back  = laneCars[i];

      const dz = back.position.z - front.position.z;
      if (dz < minGap) {
        if (back === aiCar && front !== aiCar) {
          front.position.z = back.position.z - minGap;
        } else if (back !== aiCar) {
          back.position.z = front.position.z + minGap;
        }
      }
    }
  }
}

/* ======================================================
   AI CAR UPDATE (DRIVING, AVOIDANCE, STRAIGHT PARKING)
====================================================== */
let globalTime = 0;

function respawnAICar() {
  const lane = Math.floor(Math.random() * 3);
  const data = aiCar.userData;
  aiCar.position.set(lanePositions[lane], 0.05, aiStartZ);

  data.laneIndex        = lane;
  data.targetLaneIndex  = lane;
  data.laneChangeFrom   = lane;
  data.isChangingLane   = false;
  data.laneChangeT      = 0;
  data.currentSpeed     = 0;
  data.drivingState     = "DRIVING";
  data.parkingSlotIndex = null;
  data.parkingTimer     = 0;

  data.parkingPhase     = 0;
  data.parkingT         = 0;
}

function updateAICar(delta) {
  if (!aiCar) return;
  const data = aiCar.userData;
  let hudReason = "";

  /* ---------- PARKING: TWO STRAIGHT PHASES (NO DIAGONAL) ---------- */
  if (data.drivingState === "PARKING_STRAIGHT") {
    const slot = parkingSlots[data.parkingSlotIndex];
    if (!slot) {
      data.drivingState = "DRIVING";
      updateHUD("");
      return;
    }

    if (data.parkingPhase === 1) {
      data.parkingT += delta / data.parkingDurZ;
      let t = Math.min(1, data.parkingT);
      t = smoothStep(t);

      const z = THREE.MathUtils.lerp(data.parkingZStart, data.parkingZEnd, t);
      aiCar.position.set(data.parkingXStart, 0.05, z);
      aiCar.rotation.y = 0;

      hudReason = "Aligning with parking slot...";

      if (data.parkingT >= 1) {
        data.parkingPhase = 2;
        data.parkingT = 0;
      }

      // Lane detection HUD
      const li = detectLaneAtX(aiCar.position.x);
      laneHighlight.position.x = lanePositions[li.laneIndex];
      laneHighlight.position.z = aiCar.position.z - 6;
      updateHUD(hudReason + "\n" + laneStatusText(li));
      return;
    }

    if (data.parkingPhase === 2) {
      data.parkingT += delta / data.parkingDurX;
      let t = Math.min(1, data.parkingT);
      t = smoothStep(t);

      const x = THREE.MathUtils.lerp(data.parkingXStart, data.parkingXEnd, t);
      aiCar.position.set(x, 0.05, data.parkingZEnd);
      aiCar.rotation.y = 0;

      hudReason = "Parking into free space...";

      if (data.parkingT >= 1) {
        data.drivingState = "PARKED";
        data.parkingTimer = 0;
        data.currentSpeed = 0;
        hudReason = "Parked. Preparing for next trip...";
      }

      const li = detectLaneAtX(aiCar.position.x);
      laneHighlight.position.x = lanePositions[li.laneIndex];
      laneHighlight.position.z = aiCar.position.z - 6;
      updateHUD(hudReason + "\n" + laneStatusText(li));
      return;
    }
  }

  /* ---------- PARKED ---------- */
  if (data.drivingState === "PARKED") {
    data.currentSpeed = 0;
    data.parkingTimer += delta;

    const li = detectLaneAtX(aiCar.position.x);
    laneHighlight.position.x = lanePositions[li.laneIndex];
    laneHighlight.position.z = aiCar.position.z - 6;

    updateHUD("Parked. Preparing for next trip...\n" + laneStatusText(li));
    if (data.parkingTimer > 4) {
      respawnAICar();
      updateHUD("New trip started...");
    }
    return;
  }

  /* ---------- NORMAL DRIVING / GOING_TO_PARK ---------- */
  const carZ = aiCar.position.z;
  let targetSpeed = data.baseMaxSpeed;

  // 1) Plan parking when entering parking zone
  if (data.drivingState === "DRIVING" && carZ < parkingZoneTriggerZ) {
    let bestIndex = null;
    let bestDist  = Infinity;
    parkingSlots.forEach((slot, index) => {
      if (slot.occupiedStatic) return;
      if (carZ > slot.z) {
        const dist = carZ - slot.z;
        if (dist < bestDist) {
          bestDist = dist;
          bestIndex = index;
        }
      }
    });
    if (bestIndex !== null) {
      data.drivingState = "GOING_TO_PARK";
      data.parkingSlotIndex = bestIndex;
      hudReason = "Scanning & selecting parking slot";
    }
  }

  // 2) Car ahead safety
  const aheadInfo = findCarAhead(carZ, data.laneIndex, 40);
  if (aheadInfo) {
    const safeDist = 8;
    if (aheadInfo.dist < safeDist) {
      targetSpeed = 0;
      hudReason = "Slowing down for traffic ahead";
    } else {
      const factor = (aheadInfo.dist - safeDist) / safeDist;
      const allowed = data.baseMaxSpeed * Math.max(0.0, Math.min(1.0, factor));
      targetSpeed = Math.min(targetSpeed, allowed);
      if (!hudReason) hudReason = "Adjusting speed for traffic ahead";
    }
  }

  // 3) Car coming from behind
  const behindInfo = findCarBehind(carZ, data.laneIndex, 25);
  if (behindInfo && data.drivingState !== "GOING_TO_PARK") {
    const behindCarSpeed = behindInfo.car.userData.speed;
    if (behindCarSpeed > data.currentSpeed + 1) {
      targetSpeed = Math.min(data.baseMaxSpeed, Math.max(targetSpeed, behindCarSpeed));
      if (!hudReason) hudReason = "Avoiding car from behind";
    }
  }

  // 4) Traffic light braking
  const lightInfo = findRedOrYellowLightAhead(carZ);
  if (lightInfo) {
    const brakingDist = 40;
    const t = Math.max(0, Math.min(1, lightInfo.dist / brakingDist));
    const maxSpeedDueToLight = data.baseMaxSpeed * t;
    targetSpeed = Math.min(targetSpeed, maxSpeedDueToLight);

    if (lightInfo.state === "red") {
      hudReason = "Slowing for red light";
    } else if (lightInfo.state === "yellow") {
      hudReason = "Slowing for yellow light";
    }

    if (lightInfo.dist < 2) {
      targetSpeed = 0;
      hudReason = "Stopped at signal";
    }
  }

  // 5) Pothole avoidance (disabled while GOING_TO_PARK to not miss parking)
  const potholeInfo = (data.drivingState === "GOING_TO_PARK")
    ? null
    : findPotholeAhead(carZ, data.laneIndex, 30);

  let avoidingViaLaneChange = false;

  if (potholeInfo) {
    const distToPothole = potholeInfo.dist;
    const stopBuffer    = potholeInfo.r + 4;

    const canStartLaneChange =
      !data.isChangingLane &&
      (globalTime - data.lastLaneChangeTime > data.laneChangeCooldown);

    if (canStartLaneChange) {
      const rightLane = data.laneIndex + 1;
      const leftLane  = data.laneIndex - 1;
      let changed = false;

      if (!changed && canChangeToLane(carZ, rightLane)) {
        data.targetLaneIndex = rightLane;
        data.laneChangeFrom  = data.laneIndex;
        data.isChangingLane  = true;
        data.laneChangeT     = 0;
        data.lastLaneChangeTime = globalTime;
        changed = true;
      }
      if (!changed && canChangeToLane(carZ, leftLane)) {
        data.targetLaneIndex = leftLane;
        data.laneChangeFrom  = data.laneIndex;
        data.isChangingLane  = true;
        data.laneChangeT     = 0;
        data.lastLaneChangeTime = globalTime;
        changed = true;
      }

      avoidingViaLaneChange = changed;
      if (changed) hudReason = "Changing lane to avoid pothole";
    }

    if (!avoidingViaLaneChange) {
      const brakingDist = 35;
      const effectiveDist = distToPothole - stopBuffer;
      const t = Math.max(0, Math.min(1, effectiveDist / brakingDist));
      const maxSpeedDueToPothole = data.baseMaxSpeed * t;
      targetSpeed = Math.min(targetSpeed, maxSpeedDueToPothole);

      if (!hudReason) hudReason = "Slowing down for pothole";

      if (effectiveDist < 1) {
        targetSpeed = 0;
        hudReason = "Stopped before pothole";
      }
    }
  }

  // 6) Overtaking slower car (when safe, and only in DRIVING)
  if (!data.isChangingLane && aheadInfo && targetSpeed < data.baseMaxSpeed * 0.7) {
    const farFromLight = !lightInfo || lightInfo.dist > 20;
    const okToTryOvertake = (globalTime - data.lastLaneChangeTime > data.laneChangeCooldown);

    if (farFromLight && !potholeInfo && okToTryOvertake && data.drivingState === "DRIVING") {
      const rightLane = data.laneIndex + 1;
      const leftLane  = data.laneIndex - 1;

      let changed = false;
      if (!changed && canChangeToLane(carZ, rightLane)) {
        data.targetLaneIndex = rightLane;
        data.laneChangeFrom  = data.laneIndex;
        data.isChangingLane  = true;
        data.laneChangeT     = 0;
        data.lastLaneChangeTime = globalTime;
        changed = true;
      }
      if (!changed && canChangeToLane(carZ, leftLane)) {
        data.targetLaneIndex = leftLane;
        data.laneChangeFrom  = data.laneIndex;
        data.isChangingLane  = true;
        data.laneChangeT     = 0;
        data.lastLaneChangeTime = globalTime;
        changed = true;
      }
      if (changed && !hudReason) hudReason = "Changing lane to overtake";
    }
  }

  // 7) GOING_TO_PARK: commit to slot, slow based on distance, never miss
  if (data.drivingState === "GOING_TO_PARK") {
    if (!hudReason) hudReason = "Heading to parking area";

    const slot = parkingSlots[data.parkingSlotIndex];
    if (slot) {
      let distToSlot = carZ - slot.z;

      const slotBrakeRange = 60;
      const tSlot = THREE.MathUtils.clamp(distToSlot / slotBrakeRange, 0, 1);
      const maxSlotSpeed = data.baseMaxSpeed * tSlot;
      targetSpeed = Math.min(targetSpeed, maxSlotSpeed);

      if (distToSlot <= 0) {
        targetSpeed = 0;
      }

      if (
        data.laneIndex !== parkingLaneIndex &&
        !data.isChangingLane &&
        (globalTime - data.lastLaneChangeTime > data.laneChangeCooldown) &&
        canChangeToLane(carZ, parkingLaneIndex)
      ) {
        data.targetLaneIndex = parkingLaneIndex;
        data.laneChangeFrom  = data.laneIndex;
        data.isChangingLane  = true;
        data.laneChangeT     = 0;
        data.lastLaneChangeTime = globalTime;
        hudReason = "Moving to parking lane";
      }

      if (
        Math.abs(distToSlot) < 10 &&
        data.laneIndex === parkingLaneIndex &&
        !data.isChangingLane
      ) {
        data.drivingState  = "PARKING_STRAIGHT";
        data.parkingPhase  = 1;
        data.parkingT      = 0;

        data.parkingZStart = aiCar.position.z;
        data.parkingZEnd   = slot.z;
        data.parkingXStart = lanePositions[parkingLaneIndex];
        data.parkingXEnd   = slot.x;

        hudReason = "Starting parking transition";
      }
    }
  }

  // 8) Smooth acceleration / braking
  targetSpeed = Math.max(0, Math.min(targetSpeed, data.baseMaxSpeed));

  if (targetSpeed > data.currentSpeed) {
    data.currentSpeed = Math.min(
      data.currentSpeed + data.accel * delta,
      targetSpeed
    );
  } else {
    data.currentSpeed = Math.max(
      data.currentSpeed - data.decel * delta,
      targetSpeed
    );
  }

  if (!hudReason) {
    hudReason = (data.drivingState === "GOING_TO_PARK")
      ? "Heading to parking area"
      : "Cruising normally";
  }

  // 9) Move car along -Z
  aiCar.position.z -= data.currentSpeed * delta;

  if (aiCar.position.z < -950 && data.drivingState === "DRIVING") {
    aiCar.position.z += 1800;
  }

  // 10) Smooth lane change
  if (data.isChangingLane) {
    data.laneChangeT += delta / data.laneChangeDuration;
    let t = Math.min(1, data.laneChangeT);
    t = smoothStep(t);

    const fromX = lanePositions[data.laneChangeFrom];
    const toX   = lanePositions[data.targetLaneIndex];
    aiCar.position.x = THREE.MathUtils.lerp(fromX, toX, t);

    if (data.laneChangeT >= 1) {
      data.isChangingLane = false;
      data.laneIndex      = data.targetLaneIndex;
      data.laneChangeT    = 0;
    }
  }

  /* ---------- LANE DETECTION + AUTO CENTER (ONLY WHEN CRUISING) ---------- */
  // compute lane info after all X updates (lane-change etc.)
  const laneInfo = detectLaneAtX(aiCar.position.x);

  // visual highlight follows detected lane
  laneHighlight.position.x = lanePositions[laneInfo.laneIndex];
  laneHighlight.position.z = aiCar.position.z - 6;

  // gentle lane-keep: ONLY in DRIVING state, not changing lane
  const canAssist =
    laneDetect.enabled &&
    laneDetect.autoCenter &&
    data.drivingState === "DRIVING" &&
    !data.isChangingLane;

  if (canAssist && laneInfo.absOffset < laneDetect.maxSnapDist) {
    const targetX = lanePositions[laneInfo.laneIndex];
    const alpha = 1 - Math.exp(-delta * laneDetect.steerStrength);
    aiCar.position.x = THREE.MathUtils.lerp(aiCar.position.x, targetX, alpha);

    // keep logical lane in sync with detection while cruising
    data.laneIndex = laneInfo.laneIndex;
    data.targetLaneIndex = laneInfo.laneIndex;
  }

  // HUD with lane detection appended
  updateHUD(hudReason + "\n" + laneStatusText(detectLaneAtX(aiCar.position.x)));
}

/* ======================================================
   LIGHTS + CAMERA FOLLOW
====================================================== */
const sun = new THREE.DirectionalLight(0xffffff, 1.2);
sun.position.set(40, 60, 20);
scene.add(sun);

const ambient = new THREE.AmbientLight(0xffffff, 0.4);
scene.add(ambient);

const cameraOffset = new THREE.Vector3(0, 6, 15);

function updateCamera(delta) {
  if (!aiCar) return;

  const desiredPos = aiCar.position.clone().add(cameraOffset);
  camera.position.lerp(
    desiredPos,
    1 - Math.exp(-delta * 5)
  );

  const lookTarget = aiCar.position.clone().add(new THREE.Vector3(0, 1, -8));
  camera.lookAt(lookTarget);
}

if (aiCar) {
  camera.position.copy(aiCar.position.clone().add(cameraOffset));
  camera.lookAt(aiCar.position.clone().add(new THREE.Vector3(0, 1, -8)));
}

/* ======================================================
   ANIMATION LOOP
====================================================== */
let lastTime = performance.now();

function animate() {
  requestAnimationFrame(animate);

  const now   = performance.now();
  let delta   = (now - lastTime) / 1000;
  lastTime    = now;
  if (delta > 0.05) delta = 0.05;
  globalTime += delta;

  updateTrafficLights(delta);
  updateObstacleCars(delta);
  updateAICar(delta);

  clouds.forEach((c) => {
    c.position.x += 0.015;
    if (c.position.x > 220) c.position.x = -220;
  });

  birds.forEach((b) => {
    b.position.x += 0.25;
    if (b.position.x > 220) b.position.x = -220;
  });

  updateCamera(delta);

  renderer.render(scene, camera);
}

animate();

/* ======================================================
   RESIZE HANDLER
====================================================== */
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
